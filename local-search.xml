<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络编程入门笔记</title>
    <link href="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="linux网络编程">Linux网络编程</h1><h1 id="一请求一线程">一请求一线程</h1><pre><code class="hljs">创建套接字之后，需要使用 `bind()` ​将套接字绑定到一个地址和端口上，然后使用 `listen()`​（对于服务器端）来等待客户端的连接请求，或者使用 `connect()`​（对于客户端）来与服务器建立连接。随后，可以使用 `accept()`​、`read()`​、`write()`​、`send()`​、`receive()` ​等函数来进行数据的传输。最后，当通信完成时，需要使用 `close()` ​来关闭套接字，释放资源。</code></pre><h2 id="socket-函数"><code>socket</code> ​函数</h2><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240627220811-zewu24o.png" alt="image">fd是 int 值，依次增加，系统内置三个 fd，所以 sockfd 从 3 开始</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><pre><code class="hljs">这个函数的参数有：</code></pre><ul><li><p>​<code>domain</code>​：指定套接字的通信域。 AF_INET 表示<strong>IPv4</strong> 网络协议，AF_INET6 表示 <strong>IPv6</strong>网络协议。除此之外，还有其他几种通信域，如 AF_UNIX用于同一台机器上的进程间通信。</p></li><li><p>​<code>type</code>​：指定套接字类型。 SOCK_STREAM表示字节流套接字，通常用于 <strong>TCP 协议</strong>； SOCK_DGRAM表示数据报套接字，通常用于 <strong>UDP 协议</strong>； SOCK_RAW允许程序<strong>直接访问网络层</strong>，一般用于特殊协议的开发。</p></li><li><p>​<code>protocol</code>​：指定要使用的特定协议。通常，这个参数设为0，以选择 <code>domain</code> ​和 <code>type</code>​参数指定的默认协议。</p><p>函数的返回值是一个文件描述符，用于在后续的套接字操作中引用这个新创建的套接字。如果<code>socket</code> ​调用失败，它将返回-1，并设置全局变量<code>errno</code> ​来表示错误原因。</p></li></ul><h2 id="sockaddr_in-结构">sockaddr_in 结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveraddr</span>;</span><br><span class="hljs-built_in">memset</span>(&amp;serveraddr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in));<br>serveraddr.sin_family = AF_INET;<br>serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);<br>serveraddr.sin_port = htons(<span class="hljs-number">2046</span>);<br></code></pre></td></tr></table></figure><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240702110512-zjiywdf.png" alt="image">​</p><ol type="1"><li>​<code>sin_family</code>​：地址族。对于<code>sockaddr_in</code>​，它通常被设置为<code>AF_INET</code>​，表示该结构体用于 IPv4 网络地址。</li><li>​<code>sin_port</code>​：端口号。这是一个 16位的数值，它存储了网络通信中使用的端口号。网络字节顺序（大端序）通常用于存储这个值，因此在使用之前需要用<code>htons()</code>​ 函数将其从主机字节顺序转换为网络字节顺序。</li><li>​<code>sin_addr</code>​：IP 地址。这是一个 <code>in_addr</code>​结构体，用于存储 32 位的 IPv4 地址。通常使用<code>htonl(INADDR_ANY)</code>​来指定服务器可以绑定到任何可用的本地地址，或者可以使用具体的 IP地址来代替 <code>INADDR_ANY</code>​。</li><li>​<code>sin_zero</code>​：填充字段。这是一个 8 字节的数组，用于将<code>sockaddr_in</code>​ 结构体填充到与 <code>sockaddr</code>​结构体相同的长度，以便可以强制转换这两种类型。通常，这个字段被设置为0。​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240702110722-65d2ysc.png" alt="image"></li><li>​<code>htonl()</code>​ 和 <code>htons()</code>​函数用于将主机字节顺序转换为网络字节顺序。在网络中，数据以标准字节顺序（大端序）发送，而主机可能使用大端序或小端序。<code>htonl()</code>​函数转换 32 位，而 <code>htons()</code> ​函数转换 16 位。</li></ol><h2 id="bindlistenaccept">bind、listen、accept</h2><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240702121710-psg620a.png" alt="image">​</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == bind(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serveraddr, <br><span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr))) &#123;<br>perror(<span class="hljs-string">&quot;bind&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>    listen(sockfd, <span class="hljs-number">10</span>); <span class="hljs-comment">//第二个参数为最大客户端连接数</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientaddr</span>;</span><br><span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(clientaddr);<br><span class="hljs-type">int</span> clientfd = accept(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;len);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept\n&quot;</span>);<br><span class="hljs-type">pthread_t</span> thid;<br>pthread_create(&amp;thid, <span class="hljs-literal">NULL</span>, client_thread, &amp;clientfd);<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">使用 `bind()` ​将套接字绑定(设置)到一个地址和端口上，然后使用 `listen()`​（对于服务器端）来等待客户端的连接请求。</code></pre><h2 id="accept-函数">accept 函数</h2><pre><code class="hljs">​`accept`​ 函数是用来接收一个传入的连接请求的。当一个服务器 socket 监听某个端口时，`accept`​ 函数会**阻塞**直到有一个客户端尝试连接到这个端口。当有连接请求时，`accept`​ 函数会创建一个新的 socket（通常称为连接 socket 或客户端 socket），用于与客户端进行通信，并返回这个新 socket 的文件描述符。以下是 `accept`​ 函数的声明和参数说明：</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span></span>;<br></code></pre></td></tr></table></figure><pre><code class="hljs">参数解释：</code></pre><ul><li>​<code>sockfd</code>​：这是服务器 socket 的文件描述符，它必须已经通过<code>socket</code>​ 函数创建，并且<strong>已经通过</strong><code>bind</code>​ <strong>绑定</strong>到一个地址和端口，以及通过<code>listen</code>​ 函数<strong>进行了监听</strong>。</li><li>​<code>addr</code>​：这是一个指向 <code>sockaddr</code>​结构的指针，用于<strong>存储发起连接的客户端的地址信息</strong>。这个参数通常是一个指向<code>sockaddr_in</code>​ 结构的指针，然后通过类型转换使其符合<code>sockaddr</code>​指针的类型。如果对客户端的地址不感兴趣，<strong>可以传递</strong><strong>​<code>NULL</code>​</strong>​。</li><li>​<code>addrlen</code>​：这是一个指向 <code>socklen_t</code>​类型的指针，用于指定 <code>addr</code>​ 结构的大小。在调用<code>accept</code>​ 之前，它通常被设置为指向一个变量，该变量包含<code>addr</code>​ 结构的大小。当 <code>accept</code>​函数返回时，这个变量<strong>会被更新</strong>为实际写入<code>addr</code>​ 结构的字节数。</li></ul><p>Note:​​</p><ul><li>哪怕不 accept()也是可以建立 TCP 连接的 <a href="https://mp.weixin.qq.com/s/oPX_JoZUaLn6sW54yppfvA">https://xiaolincoding.com/network/3_tcp/tcp_no_accpet.html</a></li></ul><h2 id="pthread_create-函数">pthread_create 函数</h2><p>在 C/C++ 中，<code>pthread_create</code>​函数用于创建一个新线程。以下是 <code>pthread_create</code>​函数的声明和参数说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span>*), <span class="hljs-type">void</span> *arg)</span></span>;<br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li>​<code>thread</code>​：这是一个指向 <code>pthread_t</code>​类型变量的指针，用于存储新创建线程的线程 ID。</li><li>​<code>attr</code>​：这是一个指向 <code>pthread_attr_t</code>​结构的指针，用于设置线程的属性。如果传递<code>NULL</code>​，则使用默认属性。</li><li>​<code>start_routine</code>​：这是一个函数指针，指向线程开始执行时的函数。这个函数接受一个<code>void*</code>​ 类型的参数，并返回一个 <code>void*</code>​类型的值。</li><li>​<code>arg</code>​：这是一个指向 <code>void</code>​类型的指针，用于传递参数给 <code>start_routine</code>​函数。如果你需要传递多个参数，通常会传递一个指向结构体的指针。</li></ul><h2 id="recv-函数">recv 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">client_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br><span class="hljs-type">int</span> clientfd =  *(<span class="hljs-type">int</span>*)arg;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-type">char</span> buffer[<span class="hljs-number">128</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> count = recv(clientfd, buffer, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//可以写非阻塞方式</span><br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>send(clientfd, buffer, count, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;clientfd: %d, count: %d, buffer:%s \n&quot;</span>, clientfd, count, buffer);<br>&#125;<br>close(clientfd);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 C/C++ 网络编程中，<code>recv</code>​ 函数用于从 socket接收数据。以下是 <code>recv</code>​ 函数的声明和参数说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li>​<code>sockfd</code>​：这是要从中接收数据的 socket的文件描述符。它必须是一个已经建立连接的 socket（例如，通过<code>accept</code>​ 函数返回的 socket）。</li><li>​<code>buf</code>​：这是一个指向缓冲区的指针，用于存储接收到的数据。</li><li>​<code>len</code>​：这是缓冲区 <code>buf</code>​的大小，以字节为单位，表示最多接收多少数据。</li><li>​<code>flags</code>​：这是一个标志位，用于控制 <code>recv</code>​函数的行为。如果设置为 0，表示使用默认行为。如果 <code>flags</code>​参数设置了 <code>MSG_DONTWAIT</code> ​则 <code>recv</code>​函数<strong>将不会阻塞</strong>，它会立即返回，即使没有数据可读。也可以在创建时设置<code>SOCK_NONBLOCK</code>​​<code>int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);</code>​</li></ul><p>​<code>recv</code>​函数成功时返回<strong>接收到的字节数</strong>，如果<strong>连接被对方关闭，返回0</strong>，如果发生错误，返回 -1 并设置 <code>errno</code>​来指示错误原因。</p><h1 id="select-io-多路复用">select I/O 多路复用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">fd_set rfds, rset;<br>FD_ZERO(&amp;rfds);<br>FD_SET(sockfd, &amp;rfds);<br><span class="hljs-type">int</span> maxfd = sockfd;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;loop\n&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>rset = rfds;<br><span class="hljs-type">int</span> nready = select(maxfd + <span class="hljs-number">1</span>, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientaddr</span>;</span><br><span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(clientaddr);<br><span class="hljs-type">int</span> clientfd = accept(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;len);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sockfd: %d\n&quot;</span>, clientfd);<br>FD_SET(clientfd, &amp;rfds);<br>maxfd = clientfd;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240703153454-wkxqykd.png" alt="image">​</p><p>​<code>fd_set</code> ​是位图，*8 是因为一个字节 8bit，用于存放 0 到1023 的文件描述符数</p><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240703154546-qiso47d.png" alt="image">​</p><p>比如 <code>sockfd</code>​=3，实际上就是数组第一个元素的第三位置为1。</p><p><a href="https://www.cppguide.cn/pages/1dd29f/">https://www.cppguide.cn/pages/1dd29f/</a></p><p>​<code>select</code> ​函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, </span><br><span class="hljs-params">   fd_set *readfds,</span><br><span class="hljs-params">           fd_set *writefds,</span><br><span class="hljs-params">           fd_set *exceptfds,</span><br><span class="hljs-params">           <span class="hljs-keyword">struct</span> timeval *timeout)</span>;<br></code></pre></td></tr></table></figure><ul><li><p>参数 <strong>nfds</strong>， Linux 下 socket 也称fd，这个参数的值设置成所有需要使用 select 函数检测事件的 fd 中的最大 fd值加 1。</p></li><li><p>参数 <strong>readfds</strong>，需要监听可读事件的 fd集合。</p></li><li><p>参数 <strong>writefds</strong>，需要监听可写事件的 fd集合。</p></li><li><p>参数 <strong>exceptfds</strong>，需要监听异常事件 fd集合。</p></li><li><p>参数<strong>timeout</strong>，超时时间，即在这个参数设定的时间内检测这些 fd的事件，超过这个时间后 <strong>select</strong> 函数将立即返回。如果是<code>NULL</code>​ ， <code>select</code>​ 因此将无限期地阻塞，直到至少<code>rset</code>​ 一个文件描述符准备好读取。这是一个<strong>timeval</strong> 类型结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">long</span>    tv_sec;         <span class="hljs-comment">/* seconds */</span><br><span class="hljs-type">long</span>    tv_usec;        <span class="hljs-comment">/* microseconds */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="select-函数在内核中执行以下步骤"><code>select</code>​函数在内核中执行以下步骤：</h2><ol type="1"><li><p><strong>参数验证</strong>：首先，内核会验证传递给<code>select</code>​的参数，包括文件描述符集（<code>fd_set</code>​）和超时值。</p></li><li><p><strong>复制文件描述符集</strong>：内核会将用户空间中的<code>fd_set</code> ​结构<strong>复制到内核空间</strong>。这是因为<code>select</code>​需要在内核态中操作这些集合，并且不能直接访问用户空间的数据。</p></li><li><p><strong>设置监听</strong>：内核会对 <code>fd_set</code>​中的每个文件描述符设置监听。对于<code>&amp;rset</code>​（读集），内核会检查这些文件描述符是否有数据可读；对于<code>&amp;wset</code>​（写集），会检查是否可以写入数据；对于<code>&amp;eset</code>​（异常集），会检查是否有异常条件发生。</p></li><li><p><strong>阻塞和等待</strong>：如果没有任何文件描述符立即就绪，<code>select</code>​将使调用进程进入睡眠状态，直到以下任一情况发生：</p><ul><li>至少一个文件描述符变为就绪状态。</li><li>调用被信号处理程序中断。</li><li>超时发生。</li></ul></li><li><p><strong>就绪处理</strong>：当至少一个文件描述符变为就绪状态时，内核会更新相应的<code>fd_set</code>​，标记哪些文件描述符已经就绪。</p></li><li><p><strong>返回用户空间</strong>：<code>select</code>​调用结束后，内核会将<strong>更新后的</strong><strong>​<code>fd_set</code>​</strong><strong>结构</strong>复制回用户空间，并将就绪文件描述符的数量作为函数返回值。</p></li></ol><h2 id="select-内核具体更新-fd_set-的流程">select 内核具体更新 fd_set的流程：</h2><ul><li><p><strong>检查文件描述符状态</strong>： <code>vfs_poll</code>​函数返回 <code>mask</code>​，表示文件描述符的状态。</p><p>​<code>vfs_poll</code>​ 函数的大致流程如下：</p><ol type="1"><li><strong>获取文件的</strong><strong>​<code>poll</code>​</strong>​<strong>方法</strong>：每个文件对象都有一个 <code>file_operations</code>​结构，这个结构包含了文件操作的各种函数指针，包括<code>poll</code>​。</li><li><strong>调用</strong><strong>​<code>poll</code>​</strong>​<strong>方法</strong>：<code>vfs_poll</code>​ 函数调用文件对象的 <code>poll</code>​ 方法，将<code>poll</code>​ 表传递给它。</li><li><strong>返回文件状态</strong>： 文件的 <code>poll</code>​方法返回一个位掩码，这个掩码表示文件的状态。</li></ol></li><li><p><strong>设置结果位图</strong>： 根据 <code>mask</code>​更新局部变量 <code>res_in</code>​, <code>res_out</code>​,<code>res_ex</code>​。如果文件描述符不可读（或不可写、不可发生异常），对应位不设置为1，这相当于保持为 0。</p></li><li><p><strong>写回结果位图</strong>： 将局部变量 <code>res_in</code>​,<code>res_out</code>​, <code>res_ex</code>​ 中的内容写回到结果位图<code>rinp</code>​, <code>routp</code>​, <code>rexp</code>​。</p></li></ul><h2 id="linux-select-函数的缺点也是显而易见的">Linux select函数的缺点也是显而易见的：</h2><ul><li>每次调用 <strong>select</strong> 函数，都需要把 fd集合从用户态拷贝到内核态，这个开销在 fd 较多时会很大，同时每次调用<strong>select</strong> 函数都需要在内核遍历传递进来的所有fd，这个开销在 fd 较多时也很大；</li><li>单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为1024，可以通过修改宏定义然后重新编译内核的方式提升这一限制，这样非常麻烦而且效率低下；</li><li><strong>select</strong>函数在每次调用之前都要对传入参数进行重新设定，这样做也比较麻烦。</li></ul><h1 id="poll">poll</h1><p>​<code>extern int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout)</code>​</p><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240703163757-5d3pjr4.png" alt="image">​</p><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240703163843-mrm2k2y.png" alt="image">​</p><ol type="1"><li>​<code>int nready = poll(fds, maxfd + 1, -1);</code>​ 这行代码调用poll 系统调用，等待文件描述符上的事件。参数 <code>fds</code>​是文件描述符数组，<code>maxfd + 1</code>​是要监视的文件描述符数量，<code>-1</code> ​表示无限期等待。</li><li><code>if (fds[sockfd].revents &amp; POLLIN)</code>​这个条件判断用来检查监听套接字是否有读事件发生，如果有，说明有新的客户端连接。</li></ol><p>底层和 select 类似，还是循环遍历，只是参数优化。</p><h1 id="epoll">epoll</h1><p>提问：有没有 mmap？epoll 是否线程安全？</p><p>​​</p><p>​​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240703220730-61abm2x.png" alt="image">​​</p><p>​<code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code>​​例如：<code>epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);</code>​​</p><p><a href="https://icoty.github.io/2019/06/03/epoll-source/">https://icoty.github.io/2019/06/03/epoll-source/</a></p><p><a href="https://github.com/0voice/cpp_backend_awsome_blog/blob/main/%E3%80%90NO.65%E3%80%91%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9Aepoll%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%8C%E8%BF%98%E6%90%9E%E4%B8%8D%E6%87%82epoll%E7%9A%84%E7%9C%8B%E8%BF%87%E6%9D%A5.md">底层原理：epoll源码分析，还搞不懂 epoll 的看过来.md</a></p><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240704162901-5d1f034.png" alt="image">​</p><p>epoll 底层实现中有两个关键的数据结构，一个是 eventpoll 另一个是epitem，其中 eventpoll 中有两个成员变量分别是 rbr 和rdlist,前者指向一颗红黑树的根，后者指向双向链表的头。而 epitem则是红黑树节点和双向链表节点的综合体，也就是说 epitem即可作为树的节点，又可以作为链表的节点，并且 epitem中包含着用户注册的事件。</p><h2 id="当用户调用-epoll_create时会创建-eventpoll-对象包含一个红黑树和一个双链表">当用户调用epoll_create()时，会创建 eventpoll对象（包含一个红黑树和一个双链表）；</h2><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240704171558-qgvhy3o.png" alt="image">​</p><ul><li><ol type="1"><li>创建 eventpoll 对象</li><li>让 eventpoll 中的 rbr 指向空</li><li>让 eventpoll 中的 rdlist 指向空</li><li>在并发环境下进行互斥</li><li>保存 eventpoll 对象</li><li>返回 eventpoll 对象的句柄(id)</li></ol></li></ul><h2 id="而用户调用-epoll_ctlop时">而用户调用 epoll_ctl(op)时，</h2><p>该函数的逻辑其实很简单，无非就是将用户传入的参数封装为一个 epitem对象，然后根据传入的 op 是 ①EPOLL_CTL_ADD、②EPOLL_CTL_MOD 还是③EPOLL_CTL_DEL，来决定是 ① 将 epitem 对象插入红黑树中，② 更新红黑树中的epitem 对象，还是 ③ 移除红黑树中的 epitem 对象。</p><h2 id="epoll_event_callback">epoll_event_callback()</h2><p>操作系统会默默地在通过 epoll_event_callback()来管理 eventpoll对象。当有事件被触发时，操作系统则会调用 epoll_event_callback函数，将含有该事件的 epitem 添加到双向链表中。</p><p>当服务器在以下 5 种情况会调用 epoll_event_callback：</p><ol type="1"><li>客户端 connect()连入，服务器处于 SYN_RCVD 状态时</li><li>三路握手完成，服务器处于 ESTABLISHED 状态时</li><li>客户端 close()断开连接，服务器处于 FIN_WAIT_1 和 FIN_WAIT_2状态时</li><li>客户端 send/write()数据，服务器可读时</li><li>服务器可以发送数据时</li></ol><h2 id="当用户需要管理连接时只需通过-epoll_wait从-eventpoll-对象中的双链表下摘取epitem-并取出其包含的事件即可">当用户需要管理连接时，只需通过epoll_wait()从 eventpoll 对象中的双链表下"摘取"epitem并取出其包含的事件即可。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buffer[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> count = recv(connfd, buffer, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br>send(connfd, buffer, count, <span class="hljs-number">0</span>);`<br></code></pre></td></tr></table></figure><h2 id="水平触发lt-有数据就一直触发">水平触发：LT 有数据就一直触发</h2><p><strong>​<code>ev.events = EPOLLIN;</code>​</strong></p><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240703224146-p658ole.png" alt="image">​</p><h2 id="边沿触发et-只触发一次">边沿触发：ET 只触发一次</h2><p><strong>​<code>ev.events = EPOLLIN | EPOLLET;</code>​</strong></p><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240703223836-2advip1.png" alt="image">​</p><p>​<img src="/2024/07/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image-20240703230749-cci8uaw.png" alt="image">​</p><p>‍</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
